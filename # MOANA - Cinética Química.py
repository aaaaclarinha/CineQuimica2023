import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import types


k_B = 1.380648e-23  # boltzmann contant (J/K)


def mod(v):
    """
        computes the squared sum over the last axis of the numpy.ndarray v
    """
    return np.sum(v * v, axis=-1)


def pmod(v, T, m):
    """
        Maxwell-Boltzmann's distribuion of probability
        for the length of the velocity vector v at temprature T
        for a particle of mass m
    """
    return 4 * np.pi * v**2 * np.power(m / (2 * np.pi * k_B * T), 3 / 2) * np.exp(- m * v**2 / (2 * k_B * T))


class Simulation(animation.TimedAnimation):
    """
        Complete code for the ideal gas animation.
    """

    def __init__(self, n_particles, mass, rad, T, V, max_time, dt=0.2):
        """
            Initiallisation of parameters

            ::n_particles:: number of particles in the system

            ::mass:: of the particles (identicle for all of them)

            ::rad:: radius of the particles, notice that it must be
                    of the same order as (V/n_particles)^(1/3) in
                    order to see them colliding. If the radius is too
                    small then a few number of collisions would occur.
                    To remove completely the number of cillisions set the
                    radius to 0.

            ::T:: temperatura of the system, this will defie the initial
                    velocity of the particles

            ::V:: volume of the system, this could be a floating-point number or
                    a function of time. If it is a number then the volume will
                    remain constant all the time, if it is a function then at each
                    iteration the volume will be update over time.

            ::max_time:: maximum animation time
        """

        self.PART = n_particles
        self.MASS = mass
        self.RAD = rad
        self.DIAM = 2 * rad

        self.T = T

        if isinstance(V, types.FunctionType):
            self.V0 = V(0)
            self.V = V
            self.Vconst = False
        else:
            self.V0 = V
            self.V = lambda t: V
            self.Vconst = True

        self.L = np.power(self.V0, 1/3)  # side length
        self.halfL = self.L / 2
        self.A = 6 * self.L**2  # total superfice area

        self.max_time = max_time
        self.dt = dt
        self.Nt = int(max_time / self.dt)

        self.evaluate_properties()

        # velocities histogram
        self.min_v = 0
        self.max_v = self.vmax * 3
        self.dv = 0.2  # (m/s)
        self.Nv = int((self.max_v - self.min_v) / self.dv)


        self.init_particles()
        self.init_figures()

        animation.TimedAnimation.__init__(self, self.fig, interval=1, blit=True, repeat=False)

    def overlaps(self, other):
        """Does the circle of this Particle overlap that of other?"""

        return np.hypot(*(self.PART - other.PART)) < self.RAD + other.RAD

    def evaluate_properties(self):
        """
            Calculates the initial properties of the system according
            to the laws of thermodynamics.
        """
        self.U = 1.5 * self.PART * k_B * self.T
        self.vrms = np.sqrt(3 * k_B * self.T / self.MASS)
        self.vmax = np.sqrt(2 * k_B * self.T / self.MASS)
        self.vmed = np.sqrt(8 * k_B * self.T / (np.pi * self.MASS))

    def init_particles(self):
        """
            Init the particles positions and velocities.

            The initial positions are completely random inside the box.

            The initial velocities are generated by a random unitary vector with
            a length given by the average velocity (vmed) at the system temperature.
        """
        self.r = np.random.rand(self.PART, 3) * 2 * (self.halfL - self.RAD) - (self.halfL - self.RAD)

        v_polar = np.random.random((self.PART, 2))

        self.v = np.zeros((self.PART, 3))

        self.v[:, 0] = np.sin(v_polar[:, 0] * np.pi) * np.cos(v_polar[:, 1] * 2 * np.pi)
        self.v[:, 1] = np.sin(v_polar[:, 0] * np.pi) * np.sin(v_polar[:, 1] * 2 * np.pi)
        self.v[:, 2] = np.cos(v_polar[:, 0] * np.pi)

        self.v *= self.vrms

    def init_figures(self):
        """
            Init the figures, axes, lines...
        """

        self.fig = plt.figure()

        self.ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=2, rowspan=2, projection='3d')  # 3D axes
        self.ax2 = plt.subplot2grid((3, 3), (0, 2))  # x-y axes
        self.ax5 = plt.subplot2grid((3, 3), (1, 2))  # velocities axes

        # Setup ax1: 3d
        box_limits = [-self.halfL, self.halfL]
        self.ax1.set_xlim3d(box_limits)
        self.ax1.set_xlabel('X')

        self.ax1.set_ylim3d(box_limits)
        self.ax1.set_ylabel('Y')

        self.ax1.set_zlim3d(box_limits)
        self.ax1.set_zlabel('Z')

        self.line_3d = self.ax1.plot([], [], [], ls='None', marker='.', color = '#9A32CD')[0]
        #self.line_3d_cm = self.ax1.plot([0], [0], [0], ls='None', marker='.', color='r')[0]

        # setup ax2: x-y
        self.ax2.set_xlabel(r'x')
        self.ax2.set_ylabel(r'y')
        self.ax2.set_xlim(box_limits)
        self.ax2.set_ylim(box_limits)

        self.line_xy = self.ax2.plot([], [], ls='None', marker='.', color = "#9A32CD")[0]
        #self.line_xy_cm = self.ax2.plot([0], [0], ls='None', marker='.', color='r')[0]

        # setup ax5: velocities
        vs = np.linspace(0, self.vmax * 3, 50)
        self.ax5.set_xlabel(r'$v\ (m/s)$')
        self.ax5.set_ylabel(r'$N$')
        # ax5.set_ylim(0, np.ceil(self.PART * pmod(self.vmax, self.T, self.MASS) / 5))
        self.ax5.plot(vs, self.PART * pmod(vs, self.T, self.MASS) * self.dv, color='r')

        self.vel_x = np.linspace(self.min_v, self.max_v, self.Nv)
        self.vel_y = np.zeros(self.Nv)

        self.line_vel = self.ax5.plot([], [], color='#9A32CD', lw=0.5)[0]

        self.ex_p = 0.0  # impulso trocado acumulado com as paredes

        self._drawn_artists = [
            self.line_3d, #self.line_3d_cm,
            self.line_xy, #self.line_xy_cm,
            self.line_vel]

    def update_volume(self, t):
        """
            Inicializa o novo volume e mudança nos limites do 'axes'.
        """

        self.V0 = self.V(t)
        self.L = np.power(self.V0, 1/3)
        self.halfL = self.L / 2
        self.A = 6 * self.L**2

        box_limits = [-self.halfL, self.halfL]
        self.ax1.set_xlim3d(box_limits)
        self.ax1.set_ylim3d(box_limits)
        self.ax1.set_zlim3d(box_limits)
        self.ax2.set_xlim(box_limits)
        self.ax2.set_ylim(box_limits)


    def _draw_frame(self, t):
        self.update_volume(t)

        # atualiza a posição
        self.r += self.dt * self.v

        # colisão entre as duas partículas
        dists = np.sqrt(mod(self.r - self.r[:, np.newaxis]))
        cols2 = (0 < dists) & (dists < self.DIAM)
        idx_i, idx_j = np.nonzero(cols2)
        # ***possibility to simplify this *** #
        for i, j in zip(idx_i, idx_j):
            if j < i:
                # skip duplications and same particle
                continue

            rij = self.r[i] - self.r[j]
            d = mod(rij)
            vij = self.v[i] - self.v[j]
            dv = np.dot(vij, rij) * rij / d
            self.v[i] -= dv
            self.v[j] += dv

            # atualiza as posições para que elas não permançam em contato
            self.r[i] += self.dt * self.v[i]
            self.r[j] += self.dt * self.v[j]

        # colisão das paredes
        walls = np.nonzero(np.abs(self.r) + self.RAD > self.halfL)
        self.v[walls] *= -1
        self.r[walls] -= self.RAD * np.sign(self.r[walls])

        # calcula o centro de massa
        #CM = np.sum(self.r, axis=0) / self.PART

        # coloca as novas coordenadas
        self.line_3d.set_data(self.r[:, 0], self.r[:, 1])
        self.line_3d.set_3d_properties(self.r[:, 2])

        #self.line_3d_cm.set_data(CM[0], CM[1])
        #self.line_3d_cm.set_3d_properties(CM[2])

        self.line_xy.set_data(self.r[:, 0], self.r[:, 1])
        #self.line_xy_cm.set_data(CM[0], CM[1])


        # vamos fazer o histograma de velocidade?
        v_mod = np.sqrt(mod(self.v))

        for k in range(self.Nv):
            self.vel_y[k] = np.count_nonzero((k*self.dv < v_mod) & (v_mod < (k + 1)*self.dv))

        self.line_vel.set_data(self.vel_x, self.vel_y)

        # adicione o momento trocado nesta iteração ao acumulado
        self.ex_p += 2 * self.MASS * np.sum(np.abs(self.v[walls]))

    def new_frame_seq(self):
        return iter(np.linspace(0, self.max_time, self.Nt))


def V(t, V0, Vf, t_max):
    return V0 + (Vf - V0) * t / t_max


# Dados definidos para o nosso problema
particulazinhas = 300
massa = 1.2e-20
raio = 0.01
temperatura = 200
V0, Vf = 0.5, 15
T_MAX = 1000

ani = Simulation(particulazinhas, massa, raio, temperatura, 2, T_MAX, 0.05)
plt.show()
